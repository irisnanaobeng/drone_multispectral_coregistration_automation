---
title: "Drone Multispectral Coregistration (Crop Dataset) - Complete Fusion"
author: "Iris Nana Obeng"
date: "2026-02-04"
output: github_document
---

```{r setup, message=FALSE, warning=FALSE}
library(terra)
library(imager)
library(RNiftyReg)
library(RNifti)

knitr::opts_chunk$set(dev = "png")

setwd("~/Desktop/drone ms coregistration")
```

## Load multispectral bands

```{r load-images}
files <- c("ms_crop_gre.tif", "ms_crop_red.tif", "ms_crop_nir.tif")
ms <- rast(files)
names(ms) <- c("Green", "Red", "NIR")
```

## Shift Functions

```{r shift-functions}

align_band_simple <- function(ref_mat, target_mat, max_shift = 20) {
  best_cor <- -Inf; best_dx <- 0; best_dy <- 0
  rows <- nrow(ref_mat); cols <- ncol(ref_mat)

  for (dx in -max_shift:max_shift) {
    for (dy in -max_shift:max_shift) {

      shifted <- matrix(NA, rows, cols)

      r_dst <- (1:rows) + dy
      c_dst <- (1:cols) + dx

      ok_r <- r_dst >= 1 & r_dst <= rows
      ok_c <- c_dst >= 1 & c_dst <= cols

      shifted[r_dst[ok_r], c_dst[ok_c]] <-
        target_mat[(1:rows)[ok_r], (1:cols)[ok_c]]

      valid <- is.finite(ref_mat) & is.finite(shifted)

      if (sum(valid) > 1000) {
        cc <- suppressWarnings(cor(ref_mat[valid], shifted[valid]))
        if (!is.na(cc) && cc > best_cor) {
          best_cor <- cc; best_dx <- dx; best_dy <- dy
        }
      }
    }
  }
  list(dx = best_dx, dy = best_dy, cor = best_cor)
}

apply_shift <- function(mat, dx, dy) {
  rows <- nrow(mat); cols <- ncol(mat)
  shifted <- matrix(NA, rows, cols)

  r_dst <- (1:rows) + dy
  c_dst <- (1:cols) + dx

  ok_r <- r_dst >= 1 & r_dst <= rows
  ok_c <- c_dst >= 1 & c_dst <= cols

  shifted[r_dst[ok_r], c_dst[ok_c]] <-
    mat[(1:rows)[ok_r], (1:cols)[ok_c]]

  shifted
}
```

## Edge Detection

```{r get-edges}
get_edges <- function(img){
  im <- as.cimg(t(img))
  im <- (im - min(im)) / (max(im) - min(im))
  
  sobel_x <- as.cimg(matrix(c(-1,0,1,-2,0,2,-1,0,1),3,3))
  sobel_y <- as.cimg(matrix(c(-1,-2,-1,0,0,0,1,2,1),3,3))
  
  sobx <- imager::convolve(im, sobel_x)
  soby <- imager::convolve(im, sobel_y)
  
  edges <- sqrt(sobx^2 + soby^2)
  edges <- edges / max(edges)
  
  # Return soft edges
  t(as.matrix(edges))
}

# ---------- RED–NIR INTEGER ALIGNMENT (USING EDGES) ----------

ref_edge <- get_edges(ref_red_mat)
nir_edge <- get_edges(nir_mat)

best_cor <- -Inf
best_dx  <- 0
best_dy  <- 0

for(dx in -30:30){
  for(dy in -30:30){

    shifted <- apply_shift(nir_edge,dx,dy)
    overlap <- is.finite(ref_edge) & is.finite(shifted)

    if(sum(overlap)>1000){
      cc <- cor(ref_edge[overlap],shifted[overlap])

      if(!is.na(cc) && cc>best_cor){
        best_cor <- cc
        best_dx  <- dx
        best_dy  <- dy
      }
    }
  }
}

nir_aligned <- apply_shift(nir_mat,best_dx,best_dy)

cat(sprintf("✓ Red–NIR integer shift: dx=%d dy=%d edge-cor=%.3f\n",
            best_dx,best_dy,best_cor))
```

## Edge-based Alignment

```{r align-band-edges}

align_band_edges <- function(ref_rast, target_rast, max_shift = 30){

  ref <- as.matrix(ref_rast, wide=TRUE)
  tgt <- as.matrix(target_rast, wide=TRUE)

  ref[!is.finite(ref)] <- 0
  tgt[!is.finite(tgt)] <- 0

  ref_e <- get_edges(ref)
  tgt_e <- get_edges(tgt)

  best_cor <- -Inf; best_dx <- 0; best_dy <- 0

  for (dx in -max_shift:max_shift){
    for (dy in -max_shift:max_shift){

      shifted <- apply_shift(tgt_e, dx, dy)
      valid <- is.finite(ref_e) & is.finite(shifted)

      if (sum(valid) > 1000){
        cc <- suppressWarnings(cor(ref_e[valid], shifted[valid]))

        if (!is.na(cc) && cc > best_cor){
          best_cor <- cc
          best_dx <- dx
          best_dy <- dy
        }
      }
    }
  }

  list(dx = best_dx, dy = best_dy, cor = best_cor)
}
```

## Coregister Bands

```{r coregister}

ref_red <- ms$Red
green   <- ms$Green
nir     <- ms$NIR

ref_red_mat <- as.matrix(ref_red,wide=TRUE)
green_mat   <- as.matrix(green,wide=TRUE)
nir_mat     <- as.matrix(nir,wide=TRUE)

# -------- Green alignment --------
res_green <- align_band_simple(ref_red_mat,green_mat)

green_aligned <- apply_shift(green_mat,
                             res_green$dx,
                             res_green$dy)

green_r <- rast(green_aligned)
ext(green_r) <- ext(ref_red)
crs(green_r) <- crs(ref_red)

cat(sprintf("✓ Green aligned (dx=%d dy=%d cor=%.3f)\n",
            res_green$dx,res_green$dy,res_green$cor))

# Normalize (optional)
nir_mat_norm <- (nir_mat - min(nir_mat, na.rm=TRUE)) / (max(nir_mat, na.rm=TRUE) - min(nir_mat, na.rm=TRUE))
ref_red_mat_norm <- (ref_red_mat - min(ref_red_mat, na.rm=TRUE)) / (max(ref_red_mat, na.rm=TRUE) - min(ref_red_mat, na.rm=TRUE))

# Integer-pixel alignment
res_nir <- align_band_simple(ref_red_mat_norm, nir_mat_norm)
nir_aligned <- apply_shift(nir_mat, res_nir$dx, res_nir$dy)

# Subpixel refinement
best_dx <- 0; best_dy <- 0; best_cor <- res_nir$cor
for (dx in seq(-0.3, 0.3, by=0.05)) {
  for (dy in seq(-0.3, 0.3, by=0.05)) {
    nir_shifted <- imshift(as.cimg(t(nir_aligned)), dx, dy)
    nir_shifted <- t(as.matrix(nir_shifted))
    overlap <- !is.na(ref_red_mat) & !is.na(nir_shifted)
    if(sum(overlap) > 1000) {
      cc <- cor(ref_red_mat[overlap], nir_shifted[overlap])
      if(cc > best_cor) { best_cor <- cc; best_dx <- dx; best_dy <- dy }
    }
  }
}
nir_final <- t(as.matrix(imshift(as.cimg(t(nir_aligned)), best_dx, best_dy)))
nir_r <- rast(nir_final)
ext(nir_r) <- ext(ref_red)
crs(nir_r) <- crs(ref_red)
```

## Sub-pixel Refinement

```{r subpixel}

## Sub-pixel Refinement (EDGE-BASED)

# ---------- RED–NIR SUBPIXEL REFINEMENT (STRUCTURE BASED) ----------

ref_edge <- get_edges(as.matrix(ref_red, wide=TRUE))
nir_edge <- get_edges(nir_aligned)

best_cor <- -Inf
best_dx  <- 0
best_dy  <- 0

for(dx in seq(-0.5,0.5,by=0.05)){
  for(dy in seq(-0.5,0.5,by=0.05)){

    nir_shifted <- imshift(as.cimg(t(nir_edge)),dx,dy)
    nir_shifted <- t(as.matrix(nir_shifted))

    overlap <- is.finite(ref_edge) & is.finite(nir_shifted)

    if(sum(overlap)>1000){
      cc <- cor(ref_edge[overlap],nir_shifted[overlap])

      if(!is.na(cc) && cc>best_cor){
        best_cor <- cc
        best_dx  <- dx
        best_dy  <- dy
      }
    }
  }
}

nir_final <- imshift(
  as.cimg(t(nir_aligned)),
  best_dx,
  best_dy
)

nir_final <- t(as.matrix(nir_final))

nir_r <- ref_red
values(nir_r) <- as.vector(nir_final)

cat(sprintf("✓ Red–NIR subpixel: dx=%.2f dy=%.2f edge-cor=%.3f\n",
            best_dx,best_dy,best_cor))
```

## RGB Visualization

```{r rgb-stacks}
rg_before <- c(ms$Red, ms$Green, ms$Green)
rg_after  <- c(ref_red, green_r, green_r)

rn_before <- c(ms$Red, ms$NIR, ms$NIR)
rn_after  <- c(ref_red, nir_r, nir_r)

rgb_before <- c(ms$Green, ms$Red, ms$NIR)
rgb_after  <- c(green_r, ref_red, nir_r)
```

## Red + Green

```{r plot-rg, fig.width=12, fig.height=10}
par(mfrow = c(1,2), mar = c(2,2,3,1))

plotRGB(rg_before, r=1,g=2,b=3, stretch="lin",
        main="Red + Green - Before Alignment")

plotRGB(rg_after, r=1,g=2,b=3, stretch="lin",
        main="Red + Green - After Alignment")

par(mfrow = c(1,1))
```

## Red + NIR

```{r plot, fig.width=12, fig.height=10}
par(mfrow = c(1,2), mar = c(2,2,3,1))

plotRGB(rn_before, r=1,g=2,b=3, stretch="lin",
        main="Red + NIR - Before Alignment")

plotRGB(rn_after, r=1,g=2,b=3, stretch="lin",
        main="Red + NIR - After Alignment")

par(mfrow = c(1,1))
```

## Green + Red + NIR
```{r plot-rgb, fig.width=12, fig.height=10}
par(mfrow = c(1,2), mar = c(2,2,3,1))

plotRGB(rgb_before, r=1,g=2,b=3, stretch="lin",
        main="Green + Red + NIR - Before Alignment")

plotRGB(rgb_after, r=1,g=2,b=3, stretch="lin",
        main="Green + Red + NIR - After Alignment")

par(mfrow = c(1,1))
```

```{r}
cat("\n✓ Coregistration complete\n")
```
